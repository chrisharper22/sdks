// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.134.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64e-apple-ios16.2 -enable-objc-interop -enable-library-evolution -module-link-name swiftRegexBuilder -swift-version 5 -O -enforce-exclusivity=unchecked -module-name RegexBuilder
// swift-module-flags-ignorable: -enable-lexical-lifetimes=false -target-min-inlining-version min -user-module-version 5.7.1.134.3
import Swift
import _StringProcessing
extension Swift.BidirectionalCollection where Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func wholeMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func prefixMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func contains(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func firstRange(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent) -> Swift.Range<Self.Index>?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func ranges(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent) -> [Swift.Range<Self.Index>]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, @RegexBuilder.RegexComponentBuilder separator: () -> some RegexComponent) -> [Self.SubSequence]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func starts(@RegexBuilder.RegexComponentBuilder with content: () -> some RegexComponent) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func trimmingPrefix(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent) -> Self.SubSequence
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func firstMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func matches<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> [_StringProcessing.Regex<Output>.Match]
}
extension Swift.RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func trimPrefix(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Replacement>(with replacement: Replacement, subrange: Swift.Range<Self.Index>, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Replacement>(with replacement: Replacement, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func replace<Replacement>(with replacement: Replacement, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Output, Replacement>(subrange: Swift.Range<Self.Index>, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Output, Replacement>(maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func replace<Output, Replacement>(maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows where Replacement : Swift.Collection, Replacement.Element == Swift.Character
}
extension Swift.StringProtocol where Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(separator: Swift.String, maxSplits: Swift.Int = .max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Substring]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(separator: Swift.Substring, maxSplits: Swift.Int = .max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Substring]
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Anchor {
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Anchor : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Swift.Substring> {
    get
  }
  public typealias RegexOutput = Swift.Substring
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Anchor {
  public static var startOfSubject: RegexBuilder.Anchor {
    get
  }
  public static var endOfSubjectBeforeNewline: RegexBuilder.Anchor {
    get
  }
  public static var endOfSubject: RegexBuilder.Anchor {
    get
  }
  public static var firstMatchingPositionInSubject: RegexBuilder.Anchor {
    get
  }
  public static var textSegmentBoundary: RegexBuilder.Anchor {
    get
  }
  public static var startOfLine: RegexBuilder.Anchor {
    get
  }
  public static var endOfLine: RegexBuilder.Anchor {
    get
  }
  public static var wordBoundary: RegexBuilder.Anchor {
    get
  }
  public var inverted: RegexBuilder.Anchor {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Lookahead<Output> {
  public var regex: _StringProcessing.Regex<Output>
  public init<R>(_ component: R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public init<R>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct NegativeLookahead<Output> {
  public var regex: _StringProcessing.Regex<Output>
  public init<R>(_ component: R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public init<R>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_functionBuilder public enum RegexComponentBuilder {
  public static func buildBlock() -> _StringProcessing.Regex<Swift.Substring>
  public static func buildPartialBlock<R>(first component: R) -> _StringProcessing.Regex<R.RegexOutput> where R : _StringProcessing.RegexComponent
  public static func buildExpression<R>(_ regex: R) -> R where R : _StringProcessing.RegexComponent
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct CharacterClass {
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Swift.Substring> {
    get
  }
  public typealias RegexOutput = Swift.Substring
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public var inverted: RegexBuilder.CharacterClass {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public static var any: RegexBuilder.CharacterClass {
    get
  }
  public static var anyNonNewline: RegexBuilder.CharacterClass {
    get
  }
  public static var anyGraphemeCluster: RegexBuilder.CharacterClass {
    get
  }
  public static var whitespace: RegexBuilder.CharacterClass {
    get
  }
  public static var digit: RegexBuilder.CharacterClass {
    get
  }
  public static var hexDigit: RegexBuilder.CharacterClass {
    get
  }
  public static var horizontalWhitespace: RegexBuilder.CharacterClass {
    get
  }
  public static var newlineSequence: RegexBuilder.CharacterClass {
    get
  }
  public static var verticalWhitespace: RegexBuilder.CharacterClass {
    get
  }
  public static var word: RegexBuilder.CharacterClass {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public static func anyOf<S>(_ s: S) -> RegexBuilder.CharacterClass where S : Swift.Sequence, S.Element == Swift.Character
  public static func anyOf<S>(_ s: S) -> RegexBuilder.CharacterClass where S : Swift.Sequence, S.Element == Swift.Unicode.Scalar
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public static func generalCategory(_ category: Swift.Unicode.GeneralCategory) -> RegexBuilder.CharacterClass
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public func ... (lhs: Swift.Character, rhs: Swift.Character) -> RegexBuilder.CharacterClass
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_disfavoredOverload public func ... (lhs: Swift.UnicodeScalar, rhs: Swift.UnicodeScalar) -> RegexBuilder.CharacterClass
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public init(_ first: RegexBuilder.CharacterClass, _ rest: RegexBuilder.CharacterClass...)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public func union(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func intersection(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func subtracting(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func symmetricDifference(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.Regex {
  public init<Content>(@RegexBuilder.RegexComponentBuilder _ content: () -> Content) where Output == Content.RegexOutput, Content : _StringProcessing.RegexComponent
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.String : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.String.Output> {
    get
  }
  public typealias RegexOutput = Swift.String.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Substring : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Substring.Output> {
    get
  }
  public typealias RegexOutput = Swift.Substring.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Character : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Character.Output> {
    get
  }
  public typealias RegexOutput = Swift.Character.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Unicode.Scalar : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Unicode.Scalar.Output> {
    get
  }
  public typealias RegexOutput = Swift.Unicode.Scalar.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct One<Output> : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Output>
  public init<Component>(_ component: Component) where Output == Component.RegexOutput, Component : _StringProcessing.RegexComponent
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct OneOrMore<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ZeroOrMore<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Optionally<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Repeat<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_functionBuilder public struct AlternationBuilder {
  @_disfavoredOverload public static func buildPartialBlock<R>(first component: R) -> RegexBuilder.ChoiceOf<R.RegexOutput> where R : _StringProcessing.RegexComponent
  public static func buildExpression<R>(_ regex: R) -> R where R : _StringProcessing.RegexComponent
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ChoiceOf<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public init(@RegexBuilder.AlternationBuilder _ builder: () -> RegexBuilder.ChoiceOf<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Capture<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct TryCapture<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Local<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Reference<Capture> : _StringProcessing.RegexComponent {
  public init(_ captureType: Capture.Type = Capture.self)
  @usableFromInline
  internal var _raw: Swift.Int {
    get
  }
  public var regex: _StringProcessing.Regex<Capture> {
    get
  }
  public typealias RegexOutput = Capture
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.Regex.Match {
  public subscript<Capture>(reference: RegexBuilder.Reference<Capture>) -> Capture {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@usableFromInline
internal func makeFactory() -> _StringProcessing._RegexFactory
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7), R1.RegexOutput == (W1, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7), R1.RegexOutput == (W1, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7), R1.RegexOutput == (W1, C8, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7, C8), R1.RegexOutput == (W1, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7, C8), R1.RegexOutput == (W1, C9, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C1, C2, C3, C4, C5, C6, C7, C8, C9), R1.RegexOutput == (W1, C10) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<Swift.Substring> where W0 == R0.RegexOutput, R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, R0, R1>(accumulated: R0, next: R1) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Component>(_ component: Component) -> _StringProcessing.Regex<Swift.Substring> where Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ component: Component, count: Swift.Int) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> where Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component, R>(_ component: Component, _ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component, R>(_ expression: R, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?), Component : _StringProcessing.RegexComponent, R : Swift.RangeExpression, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R.Bound == Swift.Int {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(_ component: Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_disfavoredOverload @_alwaysEmitIntoClient public init<Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == Swift.Substring, Component : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, Component>(_ component: Component) where Output == (Swift.Substring, C1), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(_ component: Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, Component>(@RegexBuilder.RegexComponentBuilder _ component: () -> Component) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), Component : _StringProcessing.RegexComponent, Component.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<Swift.Substring> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, R1, W1, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0?, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R1.RegexOutput == (W1, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, R1, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0), R1.RegexOutput == (W1, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, R1, W1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1), R1.RegexOutput == (W1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, R1, W1, C3, C4, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2), R1.RegexOutput == (W1, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, R1, W1, C4, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4?, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3), R1.RegexOutput == (W1, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1, W1, C5>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1, W1, C5, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5?, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1, W1, C5, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5?, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1, W1, C5, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5?, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, R1, W1, C5, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5?, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4), R1.RegexOutput == (W1, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, R1, W1, C6>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, R1, W1, C6, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6?, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, R1, W1, C6, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6?, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, R1, W1, C6, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6?, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5), R1.RegexOutput == (W1, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, R1, W1, C7>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, R1, W1, C7, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7?, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, R1, W1, C7, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7?, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6), R1.RegexOutput == (W1, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, C7, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, C7, R1, W1, C8>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7), R1.RegexOutput == (W1, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, C7, R1, W1, C8, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8?, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7), R1.RegexOutput == (W1, C8, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, R1>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R0, W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, R1, W1, C9>(accumulated: R0, next: R1) -> RegexBuilder.ChoiceOf<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9?)> where R0 : _StringProcessing.RegexComponent, R1 : _StringProcessing.RegexComponent, R0.RegexOutput == (W0, C0, C1, C2, C3, C4, C5, C6, C7, C8), R1.RegexOutput == (W1, C9) {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W>(_ component: R) where Output == (Swift.Substring, W), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<R, W, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture), R : _StringProcessing.RegexComponent, W == R.RegexOutput {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1>(_ component: R) where Output == (Swift.Substring, W, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2>(_ component: R) where Output == (Swift.Substring, W, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: R, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: R, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component()))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(@RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ component: () -> R, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10), R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Lookahead : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.NegativeLookahead : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ChoiceOf : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local : _StringProcessing.RegexComponent {}
