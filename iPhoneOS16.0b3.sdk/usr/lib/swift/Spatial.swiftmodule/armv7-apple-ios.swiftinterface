// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.119.2 clang-1400.0.28.1)
// swift-module-flags: -target armv7-apple-ios10.3 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftSpatial -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name Spatial
// swift-module-flags-ignorable: -user-module-version 36
import EditLine
@_exported import Spatial
import Swift
import _Concurrency
import _StringProcessing
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.x")
public let x: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.y")
public let y: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.z")
public let z: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @available(*, deprecated, renamed: "Rotation3D.init(angle:axis:)")
  public init(axis: Spatial.RotationAxis3D, angle: Spatial.Angle2D)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatf)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
  @available(*, deprecated, message: "This property is deprecated")
  @inlinable public var origin: Spatial.Point3D {
    get {
        return self
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func distance(to other: Spatial.Rect3D) -> Swift.Double {
        return self.origin.distance(to: other.origin)
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func rotation(to other: Spatial.Rect3D) -> Spatial.Rotation3D {
        return self.origin.rotation(to: other.origin)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Point3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Rect3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Ray3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.AffineTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "offset")
  @inlinable public var translation: Spatial.Size3D {
    get {
        let v = self.offset
        
        return Size3D(v)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.ProjectiveTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "offset")
  @inlinable public var translation: Spatial.Size3D {
    get {
        let v = self.offset
        
        return Size3D(v)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPPoint3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPPoint3DMakeWithSize(size)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public mutating func clamp(to rect: Spatial.Rect3D) {
        self = self.clamped(to: rect)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Primitive3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
       
        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
        
        lhs = Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (point: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(-point.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Point3D) -> Spatial.Point3D {
        return Point3D(lhs * rhs.vector)
    }
  @inlinable public static func *= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(rhs * lhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {

        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable prefix public static func - (size: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(-size.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Spatial.AffineTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Spatial.ProjectiveTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@inlinable public func * <T>(lhs: Spatial.Rotation3D, rhs: T) -> T where T : Spatial.Rotatable3D {
    
    let result = rhs.rotated(by: lhs)
    
    return result
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (vector: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(-vector.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Swift.Bool {
        return lhs.radians == rhs.radians
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPProjectiveTransform3DGetOffset(self)
        }
    set {
            __SPProjectiveTransform3DSetOffset(&self, newValue)
        }
  }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             translation)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ProjectiveTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPProjectiveTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  public func flipped(along axis: Spatial.Axis3D) -> Spatial.ProjectiveTransform3D
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Spatial.ProjectiveTransform3D {
        return __SPProjectiveTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPProjectiveTransform3DIsUniformOverDimensions(self,
                                                                axes)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.ProjectiveTransform3D {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                return __SPProjectiveTransform3DShear(self, .z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPProjectiveTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  @inlinable public var scale: Spatial.Size3D? {
    get {
        
        let s = __SPProjectiveTransform3DGetScale(self)
        
        if __SPSize3DIsValid(s) {
            return s
        } else {
            return nil
        }
    }
  }
  @inlinable public func inverted() -> Spatial.ProjectiveTransform3D? {
        
        let t = __SPProjectiveTransform3DInverted(self)
        
        if __SPProjectiveTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyAffineTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyProjectiveTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Rect3D {
        
        return __SPRect3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Rect3D {
        
        return _shear(shearFunc: __SPRect3DShear,
                      shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Volumetric {
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public mutating func formInset(by dXYZ: Spatial.Size3D) {
        
        self = self.inset(by: dXYZ)
    }
  @inlinable public func intersection(_ other: Spatial.Rect3D) -> Spatial.Rect3D? {
        let intersection = __SPRect3DIntersection(self, other)
        
        if intersection.origin.isFinite {
            return intersection
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rect3D, rhs: Spatial.Rect3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.size == rhs.size
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  public init(origin: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(origin: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(center: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(center: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(points: [Spatial.Point3D])
  public var cornerPoints: [Spatial.Point3D] {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D {
  @inlinable public init<T>(radians: T) where T : Swift.BinaryFloatingPoint {
        self.init(radians: Double(radians))
    }
  @inlinable public init<T>(degrees: T) where T : Swift.BinaryFloatingPoint {
        self.init(degrees: Double(degrees))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(rotationAxis: Spatial.RotationAxis3D) {
        self.init(x: Float(rotationAxis.x),
                  y: Float(rotationAxis.y),
                  z: Float(rotationAxis.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @inlinable public init(_ quaternion: simd.simd_quatf) {
        
        let q = simd_quatd(angle: Double(quaternion.angle),
                           axis: simd_double3(Double(quaternion.axis.x),
                                              Double(quaternion.axis.y),
                                              Double(quaternion.axis.z)))
        
        self.init(q)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_quatf {
  @inlinable public init(rotation: Spatial.Rotation3D) {
        
        self.init(vector: simd_float(rotation.quaternion.vector))
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(point: Spatial.Point3D) {
        self.init(x: Float(point.x),
                  y: Float(point.y),
                  z: Float(point.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(vector: Spatial.Vector3D) {
        self.init(x: Float(vector.x),
                  y: Float(vector.y),
                  z: Float(vector.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(width: T, height: T, depth: T) where T : Swift.BinaryFloatingPoint {
        self.init(width: Double(width),
                  height: Double(height),
                  depth: Double(depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(size: Spatial.Size3D) {
        self.init(x: Float(size.width),
                  y: Float(size.height),
                  z: Float(size.depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public init(origin: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let o = simd_double3(Double(origin.x),
                             Double(origin.y),
                             Double(origin.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        self = __SPRect3DMakeAtOriginWithVector(o, s)
    }
  @inlinable public init(center: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let c = simd_double3(Double(center.x),
                             Double(center.y),
                             Double(center.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        
        self = __SPRect3DMakeAtCenterWithVector(c, s)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public init(matrix: simd.simd_float4x3) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x3([
            simd_double3(Double(column0.x), Double(column0.y), Double(column0.z)),
            simd_double3(Double(column1.x), Double(column1.y), Double(column1.z)),
            simd_double3(Double(column2.x), Double(column2.y), Double(column2.z)),
            simd_double3(Double(column3.x), Double(column3.y), Double(column3.z))
        ])
        
        self.init(matrix: m)
    }
  @inlinable public init?(matrix: simd.simd_float4x4) {

        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        let affine = __SPAffineTransform3DMakeWith4x4Matrix(m)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x3 {
  @inlinable public init(affineTransform: Spatial.AffineTransform3D) {
        
        let column0 = affineTransform.matrix.columns.0
        let column1 = affineTransform.matrix.columns.1
        let column2 = affineTransform.matrix.columns.2
        let column3 = affineTransform.matrix.columns.3
        
        self.init([
            simd_float3(Float(column0.x), Float(column0.y), Float(column0.z)),
            simd_float3(Float(column1.x), Float(column1.y), Float(column1.z)),
            simd_float3(Float(column2.x), Float(column2.y), Float(column2.z)),
            simd_float3(Float(column3.x), Float(column3.y), Float(column3.z))
        ])
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public init(matrix: simd.simd_float4x4) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        self.init(matrix: m)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x4 {
  @inlinable public init(projectiveTransform: Spatial.ProjectiveTransform3D) {
        
        let column0 = projectiveTransform.matrix.columns.0
        let column1 = projectiveTransform.matrix.columns.1
        let column2 = projectiveTransform.matrix.columns.2
        let column3 = projectiveTransform.matrix.columns.3
        
        self.init([
            simd_float4(Float(column0.x), Float(column0.y),
                        Float(column0.z), Float(column0.w)),
            
            simd_float4(Float(column1.x), Float(column1.y),
                        Float(column1.z), Float(column1.w)),
            
            simd_float4(Float(column2.x), Float(column2.y),
                        Float(column2.z), Float(column2.w)),
            
            simd_float4(Float(column3.x), Float(column3.y),
                        Float(column3.z), Float(column3.w))
        ])
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  public init(origin: Spatial.Point3D = .zero, direction: Spatial.Vector3D)
  public init(origin: simd.simd_double3 = .zero, direction: simd.simd_double3)
  public init(origin: simd.simd_float3 = .zero, direction: simd.simd_float3)
  public func intersects(_ rect: Spatial.Rect3D) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Rotatable3D {
  public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Ray3D
  public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Ray3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Ray3D, rhs: Spatial.Ray3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.direction == rhs.direction
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : @unchecked Swift.Sendable {
  public static let right: Spatial.Vector3D
  public static let up: Spatial.Vector3D
  public static let forward: Spatial.Vector3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPVector3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPVector3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPVector3DMakeWithSize(size)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPVector3DMakeWithPoint(point)
    }
  @inlinable public init(_ axis: Spatial.RotationAxis3D) {
        self = __SPVector3DMakeWithRotationAxis(axis)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Primitive3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Vector3D {
        
        return __SPVector3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Vector3D {
        
        return _shear(shearFunc: __SPVector3DShear, shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Swift.Bool {
        
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Primitive3D : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  static var zero: Self { get }
  static var infinity: Self { get }
  var isZero: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  func applying(_ transform: Spatial.AffineTransform3D) -> Self
  func applying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  mutating func apply(_ transform: Spatial.AffineTransform3D)
  mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  func unapplying(_ transform: Spatial.AffineTransform3D) -> Self
  mutating func unapply(_ transform: Spatial.AffineTransform3D)
  func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Primitive3D {
  public mutating func apply(_ transform: Spatial.AffineTransform3D)
  public mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  public mutating func unapply(_ transform: Spatial.AffineTransform3D)
  public mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  func translated(by size: Spatial.Size3D) -> Self
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  mutating func translate(by size: Spatial.Size3D)
  func translated(by vector: Spatial.Vector3D) -> Self
  mutating func translate(by vector: Spatial.Vector3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public mutating func translate(by size: Spatial.Size3D) {
        self = self.translated(by: size)
    }
  @inlinable public func translated(by vector: Spatial.Vector3D) -> Self {
        return self.translated(by: vector)
    }
  @inlinable public mutating func translate(by vector: Spatial.Vector3D) {
        self = self.translated(by: vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Scalable3D {
  func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Self
  mutating func scaleBy(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  func scaled(by size: Spatial.Size3D) -> Self
  mutating func scale(by size: Spatial.Size3D)
  func uniformlyScaled(by scale: Swift.Double) -> Self
  mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Scalable3D {
  public mutating func scaleBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1)
  public mutating func scale(by scale: Spatial.Size3D)
  public mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Rotatable3D {
  func rotated(by rotation: Spatial.Rotation3D) -> Self
  mutating func rotate(by rotation: Spatial.Rotation3D)
  func rotated(by quaternion: simd.simd_quatd) -> Self
  mutating func rotate(by quaternion: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotatable3D {
  public mutating func rotate(by rotation: Spatial.Rotation3D)
  public mutating func rotate(by rotation: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public enum AxisWithFactors {
  case xAxis(yShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case yAxis(xShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case zAxis(xShearFactor: Swift.Double, yShearFactor: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Shearable3D {
  func sheared(_ shear: Spatial.AxisWithFactors) -> Self
  mutating func shear(_ shear: Spatial.AxisWithFactors)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Shearable3D {
  public mutating func shear(_ shear: Spatial.AxisWithFactors)
  @usableFromInline
  internal func _shear(shearFunc: (Self, Spatial.Axis3D, Swift.Double, Swift.Double) -> Self, shear: Spatial.AxisWithFactors) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Volumetric {
  var size: Spatial.Size3D { get }
  func contains(_ other: Self) -> Swift.Bool
  func contains(point: Spatial.Point3D) -> Swift.Bool
  func union(_ other: Self) -> Self
  func intersection(_ other: Self) -> Self?
  mutating func formIntersection(_ other: Self)
  mutating func formUnion(_ other: Self)
  @available(*, deprecated, renamed: "contains(anyOf:)")
  func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool
  func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Volumetric {
  public mutating func formIntersection(_ other: Self)
  public mutating func formUnion(_ other: Self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public struct Dimension3DSet : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let x: Spatial.Dimension3DSet
  public static let y: Spatial.Dimension3DSet
  public static let z: Spatial.Dimension3DSet
  public static let all: Spatial.Dimension3DSet
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = Spatial.Dimension3DSet
  public typealias Element = Spatial.Dimension3DSet
  public typealias RawValue = Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  public static let one: Spatial.Size3D
  @inlinable public init(width: Swift.Double = 0, height: Swift.Double = 0, depth: Swift.Double = 0) {
        self = __SPSize3DMake(width, height, depth)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPSize3DMakeWithVector(xyz)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPSize3DMakeWithPoint(point)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPSize3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyAffineTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyProjectiveTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Size3D {
        
        return __SPSize3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Size3D {
        
        return _shear(shearFunc: __SPSize3DShear, shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Volumetric {
  public var size: Spatial.Size3D {
    get
  }
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public func intersection(_ other: Spatial.Size3D) -> Spatial.Size3D? {
        let intersection = __SPSize3DIntersection(self, other)
        
        if intersection != Size3D.zero {
            return intersection
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height && lhs.depth == rhs.depth
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : @unchecked Swift.Sendable {
  public init(_ quaternion: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  public init(eye: Spatial.Point3D = Point3D(x: 0, y: 0, z: 0), target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0))
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rotation3D, rhs: Spatial.Rotation3D) -> Swift.Bool {
        __SPRotation3DEqualToRotation(lhs, rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.EulerAngles {
  public typealias Order = Spatial.__SPEulerAngleOrder
  public init(angles: simd.simd_float3, order: Spatial.EulerAngles.Order)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.__SPEulerAngleOrder {
  public static let pitchYawRoll: Spatial.__SPEulerAngleOrder
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPAffineTransform3DGetOffset(self)
        }
    set {
            __SPAffineTransform3DSetOffset(&self, newValue)
        }
  }
  @inlinable public func isApproximatelyEqual(to other: Spatial.AffineTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPAffineTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  @inlinable public init?(projectiveTransform transform: Spatial.ProjectiveTransform3D) {
        
        let affine = __SPAffineTransform3DMakeWithProjective(transform)
        
        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @inlinable public init?(matrix: simd.simd_double4x4) {

        let affine = __SPAffineTransform3DMakeWith4x4Matrix(matrix)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         translation)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPAffineTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.AffineTransform3D {
        return _shear(shearFunc: __SPAffineTransform3DShear, shear: shear)
    }
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPAffineTransform3DIsUniformOverDimensions(self,
                                                            axes)
    }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPAffineTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  @inlinable public func inverted() -> Spatial.AffineTransform3D? {
        
        let t = __SPAffineTransform3DInverted(self)
        
        if __SPAffineTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D {
  @inlinable public static var x: Spatial.Axis3D {
    get {
        return __SPAxisX
    }
  }
  @inlinable public static var y: Spatial.Axis3D {
    get {
        return __SPAxisY
    }
  }
  @inlinable public static var z: Spatial.Axis3D {
    get {
        return __SPAxisZ
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  public static let x: Spatial.RotationAxis3D
  public static let y: Spatial.RotationAxis3D
  public static let z: Spatial.RotationAxis3D
  public static let xy: Spatial.RotationAxis3D
  public static let yz: Spatial.RotationAxis3D
  public static let xz: Spatial.RotationAxis3D
  public static let xyz: Spatial.RotationAxis3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPRotationAxis3DMake(x, y, z)
    }
  @inlinable public var x: Swift.Double {
    get {
            return self.__x
        }
    set {
            self.__x = newValue
        }
  }
  @inlinable public var y: Swift.Double {
    get {
            return self.__y
        }
    set {
            self.__y = newValue
        }
  }
  @inlinable public var z: Swift.Double {
    get {
            return self.__z
        }
    set {
            self.__z = newValue
        }
  }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.RotationAxis3D, rhs: Spatial.RotationAxis3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Translatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Translatable3D {}
