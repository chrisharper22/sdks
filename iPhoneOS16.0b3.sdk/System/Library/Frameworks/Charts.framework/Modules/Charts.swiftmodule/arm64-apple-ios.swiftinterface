// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.119.2 clang-1400.0.28.1)
// swift-module-flags: -target arm64-apple-ios16.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name Charts
// swift-module-flags-ignorable: -user-module-version 1.0.35
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ScaleType {
  public static var linear: Charts.ScaleType {
    get
  }
  public static var log: Charts.ScaleType {
    get
  }
  public static var date: Charts.ScaleType {
    get
  }
  public static var category: Charts.ScaleType {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ScaleDomainOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ScaleDomain {
  func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ScaleRangeOutputs<VisualValue> {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ScaleRange {
  associatedtype VisualValue
  func _makeScaleRange() -> Charts._ScaleRangeOutputs<Self.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol PositionScaleRange : Charts.ScaleRange where Self.VisualValue == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.ScaleDomain where Bound : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.ScaleRange where Bound : Swift.BinaryFloatingPoint {
  public typealias VisualValue = Bound
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.ClosedRange<Bound>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.PositionScaleRange where Bound == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.ScaleDomain where Element : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.ScaleRange {
  public typealias VisualValue = Element
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.Array<Element>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.PositionScaleRange where Element == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.ScaleDomain where Element : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.ScaleRange {
  public typealias VisualValue = Element
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.ArraySlice<Element>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.PositionScaleRange where Element == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.Gradient : Charts.ScaleRange {
  public typealias VisualValue = SwiftUI.Color
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<SwiftUI.Gradient.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.AnyGradient : Charts.ScaleRange {
  public typealias VisualValue = SwiftUI.Color
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<SwiftUI.AnyGradient.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AutomaticScaleDomain : Charts.ScaleDomain, Swift.Equatable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
  public static func == (a: Charts.AutomaticScaleDomain, b: Charts.AutomaticScaleDomain) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ScaleDomain where Self == Charts.AutomaticScaleDomain {
  public static var automatic: Charts.AutomaticScaleDomain {
    get
  }
  public static func automatic(includesZero: Swift.Bool? = nil, reversed: Swift.Bool? = nil) -> Charts.AutomaticScaleDomain
  public static func automatic<DataValue>(includesZero: Swift.Bool? = nil, reversed: Swift.Bool? = nil, infer: @escaping ([DataValue]) -> [DataValue]) -> Charts.AutomaticScaleDomain where DataValue : Charts.Plottable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PlotDimensionScaleRange : Charts.PositionScaleRange {
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<CoreFoundation.CGFloat>
  public typealias VisualValue = CoreFoundation.CGFloat
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PositionScaleRange where Self == Charts.PlotDimensionScaleRange {
  public static var plotDimension: Charts.PlotDimensionScaleRange {
    get
  }
  public static func plotDimension(padding: CoreFoundation.CGFloat) -> Charts.PlotDimensionScaleRange
  public static func plotDimension(startPadding: CoreFoundation.CGFloat = 0, endPadding: CoreFoundation.CGFloat = 0) -> Charts.PlotDimensionScaleRange
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartXScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.PositionScaleRange
  
  public func chartXScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartXScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Range : Charts.PositionScaleRange
  
  public func chartXScale(type: Charts.ScaleType? = nil) -> some SwiftUI.View
  
  public func chartYScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.PositionScaleRange
  
  public func chartYScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartYScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Range : Charts.PositionScaleRange
  
  public func chartYScale(type: Charts.ScaleType? = nil) -> some SwiftUI.View
  
  public func chartForegroundStyleScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue : SwiftUI.ShapeStyle
  
  public func chartForegroundStyleScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartForegroundStyleScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Range : Charts.ScaleRange, Range.VisualValue : SwiftUI.ShapeStyle
  
  public func chartForegroundStyleScale(type: Charts.ScaleType? = nil) -> some SwiftUI.View
  
  public func chartForegroundStyleScale<DataValue, S>(_ mapping: Swift.KeyValuePairs<DataValue, S>) -> some SwiftUI.View where DataValue : Charts.Plottable, S : SwiftUI.ShapeStyle
  
  public func chartSymbolScale<Domain, Range>(domain: Domain, range: Range) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue : Charts.ChartSymbolShape
  
  @_disfavoredOverload public func chartSymbolScale<Domain>(domain: Domain, range: [any Charts.ChartSymbolShape]) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartSymbolScale<Domain>(domain: Domain) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartSymbolScale<Range>(range: Range) -> some SwiftUI.View where Range : Charts.ScaleRange, Range.VisualValue : Charts.ChartSymbolShape
  
  @_disfavoredOverload public func chartSymbolScale(range: [any Charts.ChartSymbolShape]) -> some SwiftUI.View
  
  public func chartSymbolScale<DataValue, S>(_ mapping: Swift.KeyValuePairs<DataValue, S>) -> some SwiftUI.View where DataValue : Charts.Plottable, S : Charts.ChartSymbolShape
  
  @_disfavoredOverload public func chartSymbolScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, any Charts.ChartSymbolShape>) -> some SwiftUI.View where DataValue : Charts.Plottable
  
  public func chartLineStyleScale<Domain, Range>(domain: Domain, range: Range) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue == SwiftUI.StrokeStyle
  
  public func chartLineStyleScale<Domain>(domain: Domain) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartLineStyleScale<Range>(range: Range) -> some SwiftUI.View where Range : Charts.ScaleRange, Range.VisualValue == SwiftUI.StrokeStyle
  
  public func chartLineStyleScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, SwiftUI.StrokeStyle>) -> some SwiftUI.View where DataValue : Charts.Plottable
  
  public func chartSymbolSizeScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue == CoreFoundation.CGFloat
  
  public func chartSymbolSizeScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Domain : Charts.ScaleDomain
  
  public func chartSymbolSizeScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUI.View where Range : Charts.ScaleRange, Range.VisualValue == CoreFoundation.CGFloat
  
  public func chartSymbolSizeScale(type: Charts.ScaleType? = nil) -> some SwiftUI.View
  
  public func chartSymbolSizeScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, CoreFoundation.CGFloat>) -> some SwiftUI.View where DataValue : Charts.Plottable
  
}
extension Charts.ChartContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2>(_ element1: T1, _ element2: T2) -> Charts.TupleChartContent<(T1, T2)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent {
        return TupleChartContent((element1, element2))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3>(_ element1: T1, _ element2: T2, _ element3: T3) -> Charts.TupleChartContent<(T1, T2, T3)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4) -> Charts.TupleChartContent<(T1, T2, T3, T4)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5, T6)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent, T6 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5, element6))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5, T6, T7)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent, T6 : Charts.ChartContent, T7 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5, element6, element7))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5, T6, T7, T8)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent, T6 : Charts.ChartContent, T7 : Charts.ChartContent, T8 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5, element6, element7, element8))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent, T6 : Charts.ChartContent, T7 : Charts.ChartContent, T8 : Charts.ChartContent, T9 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5, element6, element7, element8, element9))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9, _ element10: T10) -> Charts.TupleChartContent<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> where T1 : Charts.ChartContent, T2 : Charts.ChartContent, T3 : Charts.ChartContent, T4 : Charts.ChartContent, T5 : Charts.ChartContent, T6 : Charts.ChartContent, T7 : Charts.ChartContent, T8 : Charts.ChartContent, T9 : Charts.ChartContent, T10 : Charts.ChartContent {
        return TupleChartContent((element1, element2, element3, element4, element5, element6, element7, element8, element9, element10))
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct Chart<Content> : SwiftUI.View where Content : Charts.ChartContent {
  public init(@Charts.ChartContentBuilder content: () -> Content)
  public init<Data, C>(_ data: Data, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> C) where Content == SwiftUI.ForEach<Data, Data.Element.ID, C>, Data : Swift.RandomAccessCollection, C : Charts.ChartContent, Data.Element : Swift.Identifiable
  public init<Data, ID, C>(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> C) where Content == SwiftUI.ForEach<Data, ID, C>, Data : Swift.RandomAccessCollection, ID : Swift.Hashable, C : Charts.ChartContent
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts5ChartV4bodyQrvp", 0) __<Content>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartXAxis(_ visibility: SwiftUI.Visibility) -> some SwiftUI.View
  
  public func chartYAxis(_ visibility: SwiftUI.Visibility) -> some SwiftUI.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartXAxis<Content>(@Charts.AxisContentBuilder content: () -> Content) -> some SwiftUI.View where Content : Charts.AxisContent
  
  public func chartYAxis<Content>(@Charts.AxisContentBuilder content: () -> Content) -> some SwiftUI.View where Content : Charts.AxisContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AnnotationPosition : Swift.Equatable {
  public static let automatic: Charts.AnnotationPosition
  public static let overlay: Charts.AnnotationPosition
  public static let top: Charts.AnnotationPosition
  public static let bottom: Charts.AnnotationPosition
  public static let leading: Charts.AnnotationPosition
  public static let trailing: Charts.AnnotationPosition
  public static let topLeading: Charts.AnnotationPosition
  public static let topTrailing: Charts.AnnotationPosition
  public static let bottomLeading: Charts.AnnotationPosition
  public static let bottomTrailing: Charts.AnnotationPosition
  public static func == (a: Charts.AnnotationPosition, b: Charts.AnnotationPosition) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AnnotationContext {
  public let targetSize: CoreFoundation.CGSize
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUI.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, @SwiftUI.ViewBuilder content: () -> C) -> some Charts.ChartContent where C : SwiftUI.View
  
  public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUI.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, @SwiftUI.ViewBuilder content: @escaping (Charts.AnnotationContext) -> C) -> some Charts.ChartContent where C : SwiftUI.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyChartContent) public protocol ChartContent {
  associatedtype Body : Charts.ChartContent
  @Charts.ChartContentBuilder var body: Self.Body { get }
  static func _layout(_ content: Self, _ inputs: Charts._ChartContentLayoutInputs)
  static func _render(_ content: Self, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentLayoutInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentRenderInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentRenderOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public static func _layout(_ content: Self, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Self, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartLegend<Content>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUI.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil, @SwiftUI.ViewBuilder content: () -> Content) -> some SwiftUI.View where Content : SwiftUI.View
  
  public func chartLegend(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUI.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUI.View
  
  public func chartLegend(_ visibility: SwiftUI.Visibility) -> some SwiftUI.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ChartBinRange<Bound> : Swift.RangeExpression where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  public func contains(_ element: Bound) -> Swift.Bool
  public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUI.LocalizedStringKey, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
  @_disfavoredOverload public static func value<S>(_ label: S, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable, S : Swift.StringProtocol
  public static func value(_ label: SwiftUI.Text, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValueLabel<Content> : Charts.AxisMark where Content : SwiftUI.View {
  public init()
  public init(centered: Swift.Bool? = nil, anchor: SwiftUI.UnitPoint? = nil, multiLabelAlignment: SwiftUI.Alignment? = nil, collisionResolution: Charts.AxisValueLabel<Content>.CollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabel<Content>.Orientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == Swift.Never
  public init(centered: Swift.Bool? = nil, anchor: SwiftUI.UnitPoint? = nil, multiLabelAlignment: SwiftUI.Alignment? = nil, collisionResolution: Charts.AxisValueLabel<Content>.CollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabel<Content>.Orientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil, @SwiftUI.ViewBuilder content: () -> Content)
  public init(_ titleKey: SwiftUI.LocalizedStringKey, centered: Swift.Bool? = nil, anchor: SwiftUI.UnitPoint? = nil, multiLabelAlignment: SwiftUI.Alignment? = nil, collisionResolution: Charts.AxisValueLabel<Content>.CollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabel<Content>.Orientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == SwiftUI.Text
  @_disfavoredOverload public init<S>(_ title: S, centered: Swift.Bool? = nil, anchor: SwiftUI.UnitPoint? = nil, multiLabelAlignment: SwiftUI.Alignment? = nil, collisionResolution: Charts.AxisValueLabel<Content>.CollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabel<Content>.Orientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == SwiftUI.Text, S : Swift.StringProtocol
  public init<Format>(format: Format, centered: Swift.Bool? = nil, anchor: SwiftUI.UnitPoint? = nil, multiLabelAlignment: SwiftUI.Alignment? = nil, collisionResolution: Charts.AxisValueLabel<Content>.CollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabel<Content>.Orientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == Swift.Never, Format : Foundation.FormatStyle, Format.FormatInput : Charts.Plottable, Format.FormatOutput == Swift.String
  public struct CollisionResolution {
    public static var automatic: Charts.AxisValueLabel<Content>.CollisionResolution {
      get
    }
    public static var greedy: Charts.AxisValueLabel<Content>.CollisionResolution {
      get
    }
    public static func greedy(priority: Swift.Double = 0, minimumSpacing: CoreFoundation.CGFloat? = nil) -> Charts.AxisValueLabel<Content>.CollisionResolution
    public static var truncate: Charts.AxisValueLabel<Content>.CollisionResolution {
      get
    }
    public static var disabled: Charts.AxisValueLabel<Content>.CollisionResolution {
      get
    }
  }
  public struct Orientation : Swift.CustomStringConvertible {
    public static var automatic: Charts.AxisValueLabel<Content>.Orientation {
      get
    }
    public static var horizontal: Charts.AxisValueLabel<Content>.Orientation {
      get
    }
    public static var vertical: Charts.AxisValueLabel<Content>.Orientation {
      get
    }
    public static var verticalReversed: Charts.AxisValueLabel<Content>.Orientation {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public static func _layout(_ content: Charts.AxisValueLabel<Content>, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.AxisValueLabel<Content>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisMark {
  public func foregroundStyle<S>(_ style: S) -> some Charts.AxisMark where S : SwiftUI.ShapeStyle
  
  public func font(_ font: SwiftUI.Font?) -> some Charts.AxisMark
  
  public func offset(x: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.AxisMark
  
  public func offset(_ offset: CoreFoundation.CGSize) -> some Charts.AxisMark
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct MarkStackingMethod : Swift.Hashable {
  @usableFromInline
  internal let storage: Charts.MarkStackingMethod.Storage
  @usableFromInline
  @frozen internal enum Storage : Swift.Hashable {
    case standard
    case normalized
    case center
    case unstacked
    @usableFromInline
    internal static func == (a: Charts.MarkStackingMethod.Storage, b: Charts.MarkStackingMethod.Storage) -> Swift.Bool
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
  }
  @inlinable internal init(_ storage: Charts.MarkStackingMethod.Storage) {
        self.storage = storage
    }
  @inlinable public static var standard: Charts.MarkStackingMethod {
    get { .init(.standard) }
  }
  @inlinable public static var normalized: Charts.MarkStackingMethod {
    get { .init(.normalized) }
  }
  @inlinable public static var center: Charts.MarkStackingMethod {
    get { .init(.center) }
  }
  @inlinable public static var unstacked: Charts.MarkStackingMethod {
    get { .init(.unstacked) }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Charts.MarkStackingMethod, b: Charts.MarkStackingMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct MarkDimension : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
  public typealias FloatLiteralType = Swift.Double
  @usableFromInline
  internal let storage: Charts.MarkDimension.Storage
  @usableFromInline
  @frozen internal enum Storage {
    case automatic
    case fixed(CoreFoundation.CGFloat)
    case ratio(CoreFoundation.CGFloat)
    case inset(CoreFoundation.CGFloat)
  }
  @inlinable internal init(_ storage: Charts.MarkDimension.Storage) {
        self.storage = storage
    }
  @inlinable public static var automatic: Charts.MarkDimension {
    get {
        return .init(.automatic)
    }
  }
  @inlinable public static func ratio(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.ratio(value))
    }
  @inlinable public static func inset(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.inset(value))
    }
  @inlinable public static func fixed(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.fixed(value))
    }
  @inlinable public init(floatLiteral value: Swift.Double) {
        self = .fixed(CGFloat(value))
    }
  @inlinable public init(integerLiteral value: Swift.Int) {
        self = .fixed(CGFloat(value))
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct InterpolationMethod {
  @usableFromInline
  internal let storage: Charts.InterpolationMethod.Storage
  @usableFromInline
  @frozen internal enum Storage {
    case linear
    case cardinal(tension: CoreFoundation.CGFloat)
    case catmullRom(alpha: CoreFoundation.CGFloat)
    case step(transition: CoreFoundation.CGFloat)
    case monotone
    case reserved(CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  }
  @inlinable internal init(_ storage: Charts.InterpolationMethod.Storage) {
        self.storage = storage
    }
  @inlinable public static var linear: Charts.InterpolationMethod {
    get { .init(.linear) }
  }
  @inlinable public static var cardinal: Charts.InterpolationMethod {
    get { .init(.cardinal(tension: 0)) }
  }
  @inlinable public static func cardinal(tension: CoreFoundation.CGFloat) -> Charts.InterpolationMethod { .init(.cardinal(tension: tension)) }
  @inlinable public static var catmullRom: Charts.InterpolationMethod {
    get { .init(.catmullRom(alpha: 0.5)) }
  }
  @inlinable public static func catmullRom(alpha: CoreFoundation.CGFloat) -> Charts.InterpolationMethod { .init(.catmullRom(alpha: alpha)) }
  @inlinable public static var monotone: Charts.InterpolationMethod {
    get { .init(.monotone) }
  }
  @inlinable public static var stepStart: Charts.InterpolationMethod {
    get { .init(.step(transition: 0)) }
  }
  @inlinable public static var stepCenter: Charts.InterpolationMethod {
    get { .init(.step(transition: 0.5)) }
  }
  @inlinable public static var stepEnd: Charts.InterpolationMethod {
    get { .init(.step(transition: 1)) }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisMarkBuilder {
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2>(_ element1: T1, _ element2: T2) -> Charts.TupleAxisMark<(T1, T2)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark {
        return TupleAxisMark((element1, element2))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3>(_ element1: T1, _ element2: T2, _ element3: T3) -> Charts.TupleAxisMark<(T1, T2, T3)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4) -> Charts.TupleAxisMark<(T1, T2, T3, T4)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5, T6)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark, T6 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5, element6))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5, T6, T7)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark, T6 : Charts.AxisMark, T7 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5, element6, element7))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5, T6, T7, T8)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark, T6 : Charts.AxisMark, T7 : Charts.AxisMark, T8 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5, element6, element7, element8))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark, T6 : Charts.AxisMark, T7 : Charts.AxisMark, T8 : Charts.AxisMark, T9 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5, element6, element7, element8, element9))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9, _ element10: T10) -> Charts.TupleAxisMark<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> where T1 : Charts.AxisMark, T2 : Charts.AxisMark, T3 : Charts.AxisMark, T4 : Charts.AxisMark, T5 : Charts.AxisMark, T6 : Charts.AxisMark, T7 : Charts.AxisMark, T8 : Charts.AxisMark, T9 : Charts.AxisMark, T10 : Charts.AxisMark {
        return TupleAxisMark((element1, element2, element3, element4, element5, element6, element7, element8, element9, element10))
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValue {
  public func `as`<P>(_ type: P.Type) -> P? where P : Charts.Plottable
  public var index: Swift.Int {
    get
  }
  public var count: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ChartProxy : Swift.Equatable {
  public var plotAreaFrame: SwiftUI.Anchor<CoreFoundation.CGRect> {
    get
  }
  public var plotAreaSize: CoreFoundation.CGSize {
    get
  }
  public func position<P>(forX value: P) -> CoreFoundation.CGFloat? where P : Charts.Plottable
  public func position<P>(forY value: P) -> CoreFoundation.CGFloat? where P : Charts.Plottable
  public func position<X, Y>(for point: (x: X, y: Y)) -> CoreFoundation.CGPoint? where X : Charts.Plottable, Y : Charts.Plottable
  public func positionRange<P>(forX value: P) -> Swift.ClosedRange<CoreFoundation.CGFloat>? where P : Charts.Plottable
  public func positionRange<P>(forY value: P) -> Swift.ClosedRange<CoreFoundation.CGFloat>? where P : Charts.Plottable
  public func positionRange<X, Y>(for point: (x: X, y: Y)) -> CoreFoundation.CGRect? where X : Charts.Plottable, Y : Charts.Plottable
  public func value<P>(atX position: CoreFoundation.CGFloat, as: P.Type = P.self) -> P? where P : Charts.Plottable
  public func value<P>(atY position: CoreFoundation.CGFloat, as: P.Type = P.self) -> P? where P : Charts.Plottable
  public func value<X, Y>(at position: CoreFoundation.CGPoint, as: (X, Y).Type = (X, Y).self) -> (X, Y)? where X : Charts.Plottable, Y : Charts.Plottable
  public static func == (a: Charts.ChartProxy, b: Charts.ChartProxy) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartOverlay<V>(alignment: SwiftUI.Alignment = .center, @SwiftUI.ViewBuilder content: @escaping (Charts.ChartProxy) -> V) -> some SwiftUI.View where V : SwiftUI.View
  
  public func chartBackground<V>(alignment: SwiftUI.Alignment = .center, @SwiftUI.ViewBuilder content: @escaping (Charts.ChartProxy) -> V) -> some SwiftUI.View where V : SwiftUI.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func mask<C>(@Charts.ChartContentBuilder content: () -> C) -> some Charts.ChartContent where C : Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisGridLine : Charts.AxisMark {
  public init()
  public init(centered: Swift.Bool? = nil, stroke: SwiftUI.StrokeStyle? = nil)
  public static func _layout(_ content: Charts.AxisGridLine, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.AxisGridLine, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisMarks<Content> : Charts.AxisContent where Content : Charts.AxisMark {
  public init(preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: Charts.AxisMarks<Content>.Values = .automatic, @Charts.AxisMarkBuilder content: @escaping (Charts.AxisValue) -> Content)
  public init<Value>(preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: [Value], @Charts.AxisMarkBuilder content: @escaping (Charts.AxisValue) -> Content) where Value : Charts.Plottable
  public init<Format>(format: Format, preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: Charts.AxisMarks<Content>.Values = .automatic, stroke: SwiftUI.StrokeStyle? = nil) where Content == Swift.Never, Format : Foundation.FormatStyle, Format.FormatInput : Charts.Plottable, Format.FormatOutput == Swift.String
  public init<Value, Format>(format: Format, preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: [Value], stroke: SwiftUI.StrokeStyle? = nil) where Content == Swift.Never, Value : Charts.Plottable, Value == Format.FormatInput, Format : Foundation.FormatStyle, Format.FormatOutput == Swift.String
  public init(preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: Charts.AxisMarks<Content>.Values = .automatic, stroke: SwiftUI.StrokeStyle? = nil) where Content == Swift.Never
  public init<Value>(preset: Charts.AxisMarks<Content>.Preset = .automatic, position: Charts.AxisMarks<Content>.Position = .automatic, values: [Value], stroke: SwiftUI.StrokeStyle? = nil) where Content == Swift.Never, Value : Charts.Plottable
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public struct Preset : Swift.CustomStringConvertible {
    public static var automatic: Charts.AxisMarks<Content>.Preset {
      get
    }
    public static var extended: Charts.AxisMarks<Content>.Preset {
      get
    }
    public static var aligned: Charts.AxisMarks<Content>.Preset {
      get
    }
    public static var inset: Charts.AxisMarks<Content>.Preset {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public struct Position {
    public static var automatic: Charts.AxisMarks<Content>.Position {
      get
    }
    public static var leading: Charts.AxisMarks<Content>.Position {
      get
    }
    public static var trailing: Charts.AxisMarks<Content>.Position {
      get
    }
    public static var top: Charts.AxisMarks<Content>.Position {
      get
    }
    public static var bottom: Charts.AxisMarks<Content>.Position {
      get
    }
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public struct Values {
    public static var automatic: Charts.AxisMarks<Content>.Values {
      get
    }
    public static func automatic(desiredCount: Swift.Int? = nil, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarks<Content>.Values
    public static func automatic<P>(minimumStride: P, desiredCount: Swift.Int? = nil, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarks<Content>.Values where P : Swift.BinaryFloatingPoint
    public static func stride(by component: Foundation.Calendar.Component, count: Swift.Int = 1, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil, calendar: Foundation.Calendar? = nil) -> Charts.AxisMarks<Content>.Values
    public static func stride<P>(by stepSize: P, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarks<Content>.Values where P : Swift.BinaryFloatingPoint
  }
  public static func _makeAxisContent(_ content: Charts.AxisMarks<Content>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AreaMark {
  public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X, Y, S>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  public init<X, Y, S>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  public init<X, Y, S>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  public static func _layout(_ content: Charts.AreaMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.AreaMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct DateBins {
  public var thresholds: [Foundation.Date] {
    get
  }
  public init(thresholds: [Foundation.Date])
  public init(timeInterval: Foundation.TimeInterval, range: Swift.ClosedRange<Foundation.Date>)
  public init(unit: Foundation.Calendar.Component, by stride: Swift.Int = 1, range: Swift.ClosedRange<Foundation.Date>, calendar: Foundation.Calendar = .autoupdatingCurrent)
  public init(range: Swift.ClosedRange<Foundation.Date>, desiredCount: Swift.Int = 10, calendar: Foundation.Calendar = .autoupdatingCurrent)
  public init(data: [Foundation.Date], desiredCount: Swift.Int? = nil, calendar: Foundation.Calendar = .autoupdatingCurrent)
  public subscript(position: Swift.Int) -> Charts.ChartBinRange<Foundation.Date> {
    get
  }
  public func index(for value: Foundation.Date) -> Swift.Int
  public func index(after i: Swift.Int) -> Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public static func == (a: Charts.DateBins, b: Charts.DateBins) -> Swift.Bool
  public typealias Element = Charts.ChartBinRange<Foundation.Date>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<Charts.DateBins>
  public typealias Iterator = Swift.IndexingIterator<Charts.DateBins>
  public typealias SubSequence = Swift.Slice<Charts.DateBins>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisTick : Charts.AxisMark {
  public init()
  public init(centered: Swift.Bool? = nil, length: Charts.AxisTick.Length = .automatic, stroke: SwiftUI.StrokeStyle? = nil)
  public init(centered: Swift.Bool? = nil, length: CoreFoundation.CGFloat, stroke: SwiftUI.StrokeStyle? = nil)
  public struct Length {
    public static var automatic: Charts.AxisTick.Length {
      get
    }
    public static var label: Charts.AxisTick.Length {
      get
    }
    public static func label(extendPastBy: CoreFoundation.CGFloat = 0) -> Charts.AxisTick.Length
    public static var longestLabel: Charts.AxisTick.Length {
      get
    }
    public static func longestLabel(extendPastBy: CoreFoundation.CGFloat = 0) -> Charts.AxisTick.Length
  }
  public static func _layout(_ content: Charts.AxisTick, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.AxisTick, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func accessibilityLabel(_ label: SwiftUI.Text) -> some Charts.ChartContent
  
  public func accessibilityLabel(_ labelKey: SwiftUI.LocalizedStringKey) -> some Charts.ChartContent
  
  @_disfavoredOverload public func accessibilityLabel<S>(_ label: S) -> some Charts.ChartContent where S : Swift.StringProtocol
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func accessibilityValue(_ valueDescription: SwiftUI.Text) -> some Charts.ChartContent
  
  public func accessibilityValue(_ valueKey: SwiftUI.LocalizedStringKey) -> some Charts.ChartContent
  
  @_disfavoredOverload public func accessibilityValue<S>(_ value: S) -> some Charts.ChartContent where S : Swift.StringProtocol
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func accessibilityIdentifier(_ identifier: Swift.String) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func accessibilityHidden(_ hidden: Swift.Bool) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func foregroundStyle<S>(_ style: S) -> some Charts.ChartContent where S : SwiftUI.ShapeStyle
  
  public func foregroundStyle<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func alignsMarkStylesWithPlotArea(_ aligns: Swift.Bool = true) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func position<P>(by value: Charts.PlottableValue<P>, axis: SwiftUI.Axis? = nil, span: Charts.MarkDimension = .automatic) -> some Charts.ChartContent where P : Charts.Plottable
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func opacity(_ value: Swift.Double) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func blendMode(_ mode: SwiftUI.BlendMode) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func clipShape(_ shape: some Shape, style: SwiftUI.FillStyle = FillStyle()) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func lineStyle(_ style: SwiftUI.StrokeStyle) -> some Charts.ChartContent
  
  public func lineStyle<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func symbol<S>(_ symbol: S) -> some Charts.ChartContent where S : Charts.ChartSymbolShape
  
  public func symbol<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func symbolSize(_ area: CoreFoundation.CGFloat) -> some Charts.ChartContent
  
  public func symbolSize(_ size: CoreFoundation.CGSize) -> some Charts.ChartContent
  
  public func symbolSize<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func offset(x: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  public func offset(_ offset: CoreFoundation.CGSize) -> some Charts.ChartContent
  
  public func offset(x: CoreFoundation.CGFloat = 0, yStart: CoreFoundation.CGFloat = 0, yEnd: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  public func offset(xStart: CoreFoundation.CGFloat = 0, xEnd: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  public func offset(xStart: CoreFoundation.CGFloat = 0, xEnd: CoreFoundation.CGFloat = 0, yStart: CoreFoundation.CGFloat = 0, yEnd: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func cornerRadius(_ radius: CoreFoundation.CGFloat, style: SwiftUI.RoundedCornerStyle = .continuous) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  public func interpolationMethod(_ method: Charts.InterpolationMethod) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct ChartContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> Charts.EmptyChartContent {
        return EmptyChartContent()
    }
  @_alwaysEmitIntoClient public static func buildBlock<T>(_ content: T) -> T where T : Charts.ChartContent {
        return content
    }
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.ChartContent {
        return content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts._ConditionalChartContent<T1, T2> where T1 : Charts.ChartContent, T2 : Charts.ChartContent {
        return .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts._ConditionalChartContent<T1, T2> where T1 : Charts.ChartContent, T2 : Charts.ChartContent {
        return .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Content>(_ content: Content) -> some Charts.ChartContent where Content : Charts.ChartContent {
        return content
    }
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct EmptyChartContent {
  public init()
  public static func _layout(_ content: Charts.EmptyChartContent, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.EmptyChartContent, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.ChartContent {
  public var body: Swift.Never {
    get
  }
  public static func _layout(_ content: Swift.Never, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Swift.Never, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.ChartContent where Wrapped : Charts.ChartContent {
  public var body: Swift.Never {
    get
  }
  public static func _layout(_ content: Swift.Optional<Wrapped>, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Swift.Optional<Wrapped>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ConditionalChartContent<TrueContent, FalseContent> where TrueContent : Charts.ChartContent, FalseContent : Charts.ChartContent {
  @usableFromInline
  internal enum Storage {
    case trueContent(TrueContent)
    case falseContent(FalseContent)
  }
  @usableFromInline
  internal let storage: Charts._ConditionalChartContent<TrueContent, FalseContent>.Storage
  @usableFromInline
  internal init(storage: Charts._ConditionalChartContent<TrueContent, FalseContent>.Storage)
  public static func _layout(_ content: Charts._ConditionalChartContent<TrueContent, FalseContent>, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts._ConditionalChartContent<TrueContent, FalseContent>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct TupleChartContent<T> {
  @usableFromInline
  internal let value: T
  @usableFromInline
  internal init(_ content: T)
  public static func _layout(_ content: Charts.TupleChartContent<T>, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.TupleChartContent<T>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyChartContent {
  internal let storage: any Charts.ChartContent
  public init<Content>(_ content: Content) where Content : Charts.ChartContent
  public init<Content>(erasing content: Content) where Content : Charts.ChartContent
  public static func _layout(_ content: Charts.AnyChartContent, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.AnyChartContent, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PlottableValue<Value> where Value : Charts.Plottable {
  public static func value(_ labelKey: SwiftUI.LocalizedStringKey, _ value: Value) -> Charts.PlottableValue<Value>
  @_disfavoredOverload public static func value<S>(_ label: S, _ value: Value) -> Charts.PlottableValue<Value> where S : Swift.StringProtocol
  public static func value(_ label: SwiftUI.Text, _ value: Value) -> Charts.PlottableValue<Value>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUI.LocalizedStringKey, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
  @_disfavoredOverload public static func value<S>(_ label: S, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable, S : Swift.StringProtocol
  public static func value(_ label: SwiftUI.Text, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUI.LocalizedStringKey, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date
  @_disfavoredOverload public static func value<S>(_ label: S, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date, S : Swift.StringProtocol
  public static func value(_ label: SwiftUI.Text, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NumberBins<Value> where Value : Swift.Comparable, Value : Swift.Numeric {
  public var thresholds: [Value] {
    get
  }
  public init(thresholds: [Value])
  public init(size: Value, range: Swift.ClosedRange<Value>) where Value : Swift.BinaryFloatingPoint
  public init(size: Value, range: Swift.ClosedRange<Value>) where Value : Swift.BinaryInteger
  public init(range: Swift.ClosedRange<Value>, count: Swift.Int) where Value : Swift.BinaryFloatingPoint
  public init(range: Swift.ClosedRange<Value>, count: Swift.Int) where Value : Swift.BinaryInteger
  public init(range: Swift.ClosedRange<Value>, desiredCount: Swift.Int = 10, minimumStride: Value = 0) where Value : Swift.BinaryFloatingPoint
  public init(range: Swift.ClosedRange<Value>, desiredCount: Swift.Int = 10, minimumStride: Value = 0) where Value : Swift.BinaryInteger
  public init(data: [Value], desiredCount: Swift.Int? = nil, minimumStride: Value = 0) where Value : Swift.BinaryFloatingPoint
  public init(data: [Value], desiredCount: Swift.Int? = nil, minimumStride: Value = 0) where Value : Swift.BinaryInteger
  public subscript(position: Swift.Int) -> Charts.ChartBinRange<Value> {
    get
  }
  public func index(for value: Value) -> Swift.Int
  public func index(after i: Swift.Int) -> Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public static func == (a: Charts.NumberBins<Value>, b: Charts.NumberBins<Value>) -> Swift.Bool
  public typealias Element = Charts.ChartBinRange<Value>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<Charts.NumberBins<Value>>
  public typealias Iterator = Swift.IndexingIterator<Charts.NumberBins<Value>>
  public typealias SubSequence = Swift.Slice<Charts.NumberBins<Value>>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct LineMark {
  public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X, Y, S>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  public static func _layout(_ content: Charts.LineMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.LineMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ChartPlotContent : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts16ChartPlotContentV4bodyQrvp", 0) __
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.View {
  public func chartPlotStyle<Content>(@SwiftUI.ViewBuilder content: @escaping (Charts.ChartPlotContent) -> Content) -> some SwiftUI.View where Content : SwiftUI.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct BarMark {
  public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic, height: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable
  public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Y : Charts.Plottable
  public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  public static func _layout(_ content: Charts.BarMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.BarMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct RectangleMark {
  public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable
  public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where Y : Charts.Plottable
  public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil)
  public static func _layout(_ content: Charts.RectangleMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.RectangleMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.ForEach : Charts.ChartContent where Content : Charts.ChartContent {
  public var body: Swift.Never {
    get
  }
  public static func _layout(_ content: SwiftUI.ForEach<Data, ID, Content>, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: SwiftUI.ForEach<Data, ID, Content>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.ForEach where ID == Data.Element.ID, Content : Charts.ChartContent, Data.Element : Swift.Identifiable {
  public init(_ data: Data, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> Content)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.ForEach where Content : Charts.ChartContent {
  public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> Content)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct AxisMarkBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> Charts.EmptyAxisMark {
        return EmptyAxisMark()
    }
  @_alwaysEmitIntoClient public static func buildBlock<T>(_ content: T) -> T where T : Charts.AxisMark {
        return content
    }
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.AxisMark {
        return content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts._ConditionalAxisMark<T1, T2> where T1 : Charts.AxisMark, T2 : Charts.AxisMark {
        return .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts._ConditionalAxisMark<T1, T2> where T1 : Charts.AxisMark, T2 : Charts.AxisMark {
        return .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Content>(_ content: Content) -> some Charts.AxisMark where Content : Charts.AxisMark {
        return AnyAxisMark(content)
    }
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct TupleAxisContent<T> : Charts.AxisContent {
  @usableFromInline
  internal init(_ value: T)
  public static func _makeAxisContent(_ content: Charts.TupleAxisContent<T>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct TupleAxisMark<T> : Charts.AxisMark {
  @usableFromInline
  internal let value: T
  @usableFromInline
  internal init(_ content: T)
  public static func _layout(_ content: Charts.TupleAxisMark<T>, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.TupleAxisMark<T>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ChartSymbolShape : SwiftUI.Shape {
  var perceptualUnitRect: CoreFoundation.CGRect { get }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartSymbolShape where Self : SwiftUI.InsettableShape {
  public func strokeBorder(lineWidth: CoreFoundation.CGFloat = 1) -> some Charts.ChartSymbolShape
  
  public func strokeBorder(style: SwiftUI.StrokeStyle) -> some Charts.ChartSymbolShape
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyChartSymbolShape : Charts.ChartSymbolShape {
  internal let storage: any Charts.ChartSymbolShape
  public init<T>(_ content: T) where T : Charts.ChartSymbolShape
  public func path(in rect: CoreFoundation.CGRect) -> SwiftUI.Path
  public var perceptualUnitRect: CoreFoundation.CGRect {
    get
  }
  public typealias AnimatableData = SwiftUI.EmptyAnimatableData
  public typealias Body = SwiftUI._ShapeView<Charts.AnyChartSymbolShape, SwiftUI.ForegroundStyle>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUI.Circle : Charts.ChartSymbolShape {
  public var perceptualUnitRect: CoreFoundation.CGRect {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct AxisContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> Charts.EmptyAxisContent {
        return EmptyAxisContent()
    }
  @_alwaysEmitIntoClient public static func buildBlock<T>(_ content: T) -> T where T : Charts.AxisContent {
        return content
    }
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.AxisContent {
        return content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts._ConditionalAxisContent<T1, T2> where T1 : Charts.AxisContent, T2 : Charts.AxisContent {
        return .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts._ConditionalAxisContent<T1, T2> where T1 : Charts.AxisContent, T2 : Charts.AxisContent {
        return .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Content>(_ content: Content) -> some Charts.AxisContent where Content : Charts.AxisContent {
        return AnyAxisContent(content)
    }
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2>(_ element1: T1, _ element2: T2) -> Charts.TupleAxisContent<(T1, T2)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent {
        return TupleAxisContent((element1, element2))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3>(_ element1: T1, _ element2: T2, _ element3: T3) -> Charts.TupleAxisContent<(T1, T2, T3)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4) -> Charts.TupleAxisContent<(T1, T2, T3, T4)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5, T6)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent, T6 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5, element6))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5, T6, T7)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent, T6 : Charts.AxisContent, T7 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5, element6, element7))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5, T6, T7, T8)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent, T6 : Charts.AxisContent, T7 : Charts.AxisContent, T8 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5, element6, element7, element8))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent, T6 : Charts.AxisContent, T7 : Charts.AxisContent, T8 : Charts.AxisContent, T9 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5, element6, element7, element8, element9))
    }
  @_alwaysEmitIntoClient public static func buildBlock<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(_ element1: T1, _ element2: T2, _ element3: T3, _ element4: T4, _ element5: T5, _ element6: T6, _ element7: T7, _ element8: T8, _ element9: T9, _ element10: T10) -> Charts.TupleAxisContent<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> where T1 : Charts.AxisContent, T2 : Charts.AxisContent, T3 : Charts.AxisContent, T4 : Charts.AxisContent, T5 : Charts.AxisContent, T6 : Charts.AxisContent, T7 : Charts.AxisContent, T8 : Charts.AxisContent, T9 : Charts.AxisContent, T10 : Charts.AxisContent {
        return TupleAxisContent((element1, element2, element3, element4, element5, element6, element7, element8, element9, element10))
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PointMark {
  public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(x: Charts.PlottableValue<X>, y: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  public init<Y>(x: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  public static func _layout(_ content: Charts.PointMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.PointMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyAxisContent) public protocol AxisContent {
  static func _makeAxisContent(_ content: Self, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisContentInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisContentOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct EmptyAxisContent : Charts.AxisContent {
  public init()
  public static func _makeAxisContent(_ content: Charts.EmptyAxisContent, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.AxisContent {
  public static func _makeAxisContent(_ content: Swift.Never, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyAxisContent : Charts.AxisContent {
  internal let storage: any Charts.AxisContent
  public init<T>(_ content: T) where T : Charts.AxisContent
  public init<T>(erasing content: T) where T : Charts.AxisContent
  public static func _makeAxisContent(_ content: Charts.AnyAxisContent, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.AxisContent where Wrapped : Charts.AxisContent {
  public static func _makeAxisContent(_ content: Wrapped?, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ConditionalAxisContent<TrueContent, FalseContent> : Charts.AxisContent where TrueContent : Charts.AxisContent, FalseContent : Charts.AxisContent {
  @usableFromInline
  internal enum Storage {
    case trueContent(TrueContent)
    case falseContent(FalseContent)
  }
  @usableFromInline
  internal let storage: Charts._ConditionalAxisContent<TrueContent, FalseContent>.Storage
  @usableFromInline
  internal init(storage: Charts._ConditionalAxisContent<TrueContent, FalseContent>.Storage)
  public static func _makeAxisContent(_ content: Charts._ConditionalAxisContent<TrueContent, FalseContent>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct Plot<Content> where Content : Charts.ChartContent {
  public init(@Charts.ChartContentBuilder content: () -> Content)
  public static func _layout(_ content: Charts.Plot<Content>, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.Plot<Content>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol Plottable {
  associatedtype PrimitivePlottable : Charts.Plottable
  var primitivePlottable: Self.PrimitivePlottable { get }
  init?(primitivePlottable: Self.PrimitivePlottable)
  static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Self>) -> Charts._PlottableOutputs
  static func _unwrapPlottable(_ inputs: Charts._PlottableOutputs) -> Charts._PlottableInputs<Self>?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plottable where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var primitivePlottable: Swift.String {
    get
  }
  public init?(primitivePlottable: Self.RawValue)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plottable {
  public static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Self>) -> Charts._PlottableOutputs
  public static func _unwrapPlottable(_ inputs: Charts._PlottableOutputs) -> Charts._PlottableInputs<Self>?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _PlottableInputs<T> where T : Charts.Plottable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _PlottableOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.Plottable {
  public var primitivePlottable: Swift.Never {
    get
  }
  public init?(primitivePlottable: Swift.Never)
  public static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Swift.Never>) -> Charts._PlottableOutputs
  public typealias PrimitivePlottable = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Double : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init(primitivePlottable: Swift.Double)
  public static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Swift.Double>) -> Charts._PlottableOutputs
  public static func _unwrapPlottable(_ inputs: Charts._PlottableOutputs) -> Charts._PlottableInputs<Swift.Double>?
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.String : Charts.Plottable {
  public var primitivePlottable: Swift.String {
    get
  }
  public init(primitivePlottable: Swift.String)
  public static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Swift.String>) -> Charts._PlottableOutputs
  public static func _unwrapPlottable(_ inputs: Charts._PlottableOutputs) -> Charts._PlottableInputs<Swift.String>?
  public typealias PrimitivePlottable = Swift.String
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date : Charts.Plottable {
  public var primitivePlottable: Foundation.Date {
    get
  }
  public init(primitivePlottable: Foundation.Date)
  public static func _wrapPlottable(_ inputs: Charts._PlottableInputs<Foundation.Date>) -> Charts._PlottableOutputs
  public static func _unwrapPlottable(_ inputs: Charts._PlottableOutputs) -> Charts._PlottableInputs<Foundation.Date>?
  public typealias PrimitivePlottable = Foundation.Date
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Float16 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Float : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int8 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int16 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int32 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int64 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt8 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt16 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt32 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt64 : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  public init?(primitivePlottable: Swift.Double)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct RuleMark {
  public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  public init<Y>(x: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  public static func _layout(_ content: Charts.RuleMark, _ inputs: Charts._ChartContentLayoutInputs)
  public static func _render(_ content: Charts.RuleMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyAxisMark) public protocol AxisMark {
  static func _layout(_ content: Self, _ inputs: Charts._AxisMarkLayoutInputs)
  static func _render(_ content: Self, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkLayoutInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkRenderInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkRenderOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct EmptyAxisMark : Charts.AxisMark {
  public init()
  public static func _layout(_ content: Charts.EmptyAxisMark, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.EmptyAxisMark, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.AxisMark {
  public static func _layout(_ content: Swift.Never, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Swift.Never, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyAxisMark : Charts.AxisMark {
  internal let storage: any Charts.AxisMark
  public init<T>(_ content: T) where T : Charts.AxisMark
  public init<T>(erasing content: T) where T : Charts.AxisMark
  public static func _layout(_ content: Charts.AnyAxisMark, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts.AnyAxisMark, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.AxisMark where Wrapped : Charts.AxisMark {
  public static func _layout(_ content: Wrapped?, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Wrapped?, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ConditionalAxisMark<TrueContent, FalseContent> : Charts.AxisMark where TrueContent : Charts.AxisMark, FalseContent : Charts.AxisMark {
  @usableFromInline
  internal enum Storage {
    case trueContent(TrueContent)
    case falseContent(FalseContent)
  }
  @usableFromInline
  internal let storage: Charts._ConditionalAxisMark<TrueContent, FalseContent>.Storage
  @usableFromInline
  internal init(storage: Charts._ConditionalAxisMark<TrueContent, FalseContent>.Storage)
  public static func _layout(_ content: Charts._ConditionalAxisMark<TrueContent, FalseContent>, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _render(_ content: Charts._ConditionalAxisMark<TrueContent, FalseContent>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AreaMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.DateBins : Swift.Collection {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.DateBins : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.EmptyChartContent : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts._ConditionalChartContent : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.TupleChartContent : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AnyChartContent : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.NumberBins : Swift.Collection {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.NumberBins : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.LineMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BarMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RectangleMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PointMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plot : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RuleMark : Charts.ChartContent {}
